// Generated by CoffeeScript 1.10.0
var configure,
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  slice = [].slice;

configure = function(dependencies) {
  var $assign, $asyncEachSeries, $asyncSeries, $getTimestampDate, BocoMigrate, BocoMigrateError, IrreversibleMigration, MemoryStateStore, Migration, Migrations, Migrator, NotImplemented, State;
  $assign = function(target, source) {
    var key, results, val;
    results = [];
    for (key in source) {
      if (!hasProp.call(source, key)) continue;
      val = source[key];
      results.push(target[key] = val);
    }
    return results;
  };
  $getTimestampDate = function(timestamp) {
    if (timestamp == null) {
      return null;
    }
    return new Date(timestamp);
  };
  $asyncSeries = function(series, done) {
    return require("async").series(series, done);
  };
  $asyncEachSeries = function(series, fn, done) {
    return require("async").eachSeries(series, fn, done);
  };
  BocoMigrateError = (function(superClass) {
    extend(BocoMigrateError, superClass);

    function BocoMigrateError(props) {
      $assign(this, props);
      Error.captureStackTrace(this, this.constructor);
      if (this.name == null) {
        this.name = this.constructor.name;
      }
      if (this.message == null) {
        this.message = this.getDefaultMessage();
      }
    }

    return BocoMigrateError;

  })(Error);
  IrreversibleMigration = (function(superClass) {
    extend(IrreversibleMigration, superClass);

    function IrreversibleMigration() {
      return IrreversibleMigration.__super__.constructor.apply(this, arguments);
    }

    IrreversibleMigration.prototype.migration = null;

    IrreversibleMigration.prototype.getDefaultMessage = function() {
      return "Migration '" + this.migration.name + "' is irreversible.";
    };

    return IrreversibleMigration;

  })(BocoMigrateError);
  NotImplemented = (function(superClass) {
    extend(NotImplemented, superClass);

    function NotImplemented() {
      return NotImplemented.__super__.constructor.apply(this, arguments);
    }

    NotImplemented.prototype.getDefaultMessage = function() {
      return "Not implemented";
    };

    return NotImplemented;

  })(BocoMigrateError);
  Migration = (function() {
    Migration.prototype.name = null;

    Migration.prototype.timestamp = null;

    function Migration(props) {
      $assign(this, props);
    }

    Migration.prototype.up = function(done) {
      return done(new NotImplemented());
    };

    Migration.prototype.down = function(done) {
      return done(new IrreversibleMigration({
        migration: this
      }));
    };

    Migration.prototype.getDate = function() {
      return new Date(this.timestamp);
    };

    return Migration;

  })();
  State = (function() {
    State.prototype.lastMigrationName = null;

    State.prototype.lastMigrationTimestamp = null;

    State.fromLastMigration = function(migration) {
      var state;
      return state = new State({
        lastMigrationName: migration.name,
        lastMigrationTimestamp: migration.timestamp
      });
    };

    function State(props) {
      $assign(this, props);
    }

    return State;

  })();
  MemoryStateStore = (function() {
    MemoryStateStore.prototype.stateObject = null;

    function MemoryStateStore(props) {
      $assign(this, props);
      if (this.stateObject == null) {
        this.stateObject = {};
      }
    }

    MemoryStateStore.prototype.save = function(state, done) {
      this.stateObject.lastMigrationName = state.lastMigrationName;
      this.stateObject.lastMigrationTimestamp = state.lastMigrationTimestamp;
      return done();
    };

    MemoryStateStore.prototype.fetch = function(done) {
      return done(null, new State(this.stateObject));
    };

    return MemoryStateStore;

  })();
  Migrations = (function() {
    Migrations.prototype.collection = null;

    function Migrations(props) {
      $assign(this, props);
      this.collection = this.collection != null ? this.collection.slice() : [];
    }

    Migrations.prototype.add = function(migration) {
      return this.collection.push(migration);
    };

    Migrations.prototype.getMigrationBefore = function(migration) {
      var migrationIndex;
      migrationIndex = this.collection.indexOf(migration);
      return this.collection[migrationIndex - 1];
    };

    Migrations.prototype.sortByDateAscending = function() {
      var collection;
      collection = this.collection.sort(function(a, b) {
        return a.getDate() - b.getDate();
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.sortByDateDescending = function() {
      var collection;
      collection = this.collection.sort(function(a, b) {
        return b.getDate() - a.getDate();
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.afterTimestamp = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() > date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.beforeIncludingTimestamp = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() <= date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.forMigratingUp = function(fromTimestamp, toTimestamp) {
      return this.afterTimestamp(fromTimestamp).beforeIncludingTimestamp(toTimestamp).sortByDateAscending();
    };

    Migrations.prototype.forMigratingDown = function(fromTimestamp, toTimestamp) {
      return this.beforeIncludingTimestamp(fromTimestamp).afterTimestamp(toTimestamp).sortByDateDescending();
    };

    Migrations.prototype.toArray = function() {
      return this.collection.slice();
    };

    return Migrations;

  })();
  Migrator = (function() {
    Migrator.prototype.migrations = null;

    Migrator.prototype.stateStore = null;

    function Migrator(props) {
      $assign(this, props);
      if (this.migrations == null) {
        this.migrations = new Migrations();
      }
      if (this.stateStore == null) {
        this.stateStore = new MemoryStateStore();
      }
    }

    Migrator.prototype.addMigration = function(migration) {
      return this.migrations.add(migration);
    };

    Migrator.prototype.addMigrations = function() {
      var args, i, len, migration, results;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = args.length; i < len; i++) {
        migration = args[i];
        results.push(this.addMigration(migration));
      }
      return results;
    };

    Migrator.prototype.runUpMigration = function(migration, done) {
      console.log("up: " + migration);
      return migration.up((function(_this) {
        return function(error) {
          var state;
          if (error != null) {
            return done(error);
          }
          state = State.fromLastMigration(migration);
          return _this.stateStore.save(state, done);
        };
      })(this));
    };

    Migrator.prototype.runDownMigration = function(migration, done) {
      console.log("down: " + migration);
      return migration.down((function(_this) {
        return function(error) {
          var previousMigration, state;
          if (error != null) {
            return done(error);
          }
          previousMigration = _this.migrations.sortByDateAscending().getMigrationBefore(migration);
          state = State.fromLastMigration(previousMigration);
          return _this.stateStore.save(state, done);
        };
      })(this));
    };

    Migrator.prototype.runDownMigrations = function(fromTimestamp, toTimestamp, done) {
      var migrationsToRun;
      migrationsToRun = this.migrations.forMigratingDown(fromTimestamp, toTimestamp);
      return $asyncEachSeries(migrationsToRun.toArray(), this.runDownMigration.bind(this), done);
    };

    Migrator.prototype.runUpMigrations = function(fromTimestamp, toTimestamp, done) {
      var migrationsToRun;
      migrationsToRun = this.migrations.forMigratingUp(fromTimestamp, toTimestamp);
      return $asyncEachSeries(migrationsToRun.toArray(), this.runUpMigration.bind(this), done);
    };

    Migrator.prototype.migrate = function() {
      var args, done, i;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), done = arguments[i++];
      return this.stateStore.fetch((function(_this) {
        return function(error, state) {
          var currentDate, currentTimestamp, isDownMigration, targetDate, targetTimestamp;
          if (error != null) {
            return done(error);
          }
          targetTimestamp = args[0];
          targetDate = $getTimestampDate(targetTimestamp);
          currentTimestamp = state.lastMigrationTimestamp;
          currentDate = $getTimestampDate(currentTimestamp);
          isDownMigration = (targetDate != null) && (currentDate != null) && targetDate < currentDate;
          console.log(state);
          console.log("targetTimestamp", targetTimestamp);
          console.log("currentTimestamp", currentTimestamp);
          console.log("isDownMigration", isDownMigration);
          if (isDownMigration) {
            return _this.runDownMigrations(currentTimestamp, targetTimestamp, done);
          }
          return _this.runUpMigrations(currentTimestamp, targetTimestamp, done);
        };
      })(this));
    };

    return Migrator;

  })();
  return BocoMigrate = {
    BocoMigrateError: BocoMigrateError,
    IrreversibleMigration: IrreversibleMigration,
    NotImplemented: NotImplemented,
    Migration: Migration,
    State: State,
    MemoryStateStore: MemoryStateStore,
    Migrations: Migrations,
    Migrator: Migrator
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
