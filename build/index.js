// Generated by CoffeeScript 1.10.0
var configure,
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  slice = [].slice;

configure = function(dependencies) {
  var $assign, $asyncEachSeries, $asyncSeries, $getTimestampDate, BocoMigrate, BocoMigrateError, IrreversibleMigration, MemoryStateStore, Migration, Migrations, Migrator, NotImplemented, State;
  $assign = function(target, source) {
    var key, results, val;
    results = [];
    for (key in source) {
      if (!hasProp.call(source, key)) continue;
      val = source[key];
      results.push(target[key] = val);
    }
    return results;
  };
  $getTimestampDate = function(timestamp) {
    if (timestamp == null) {
      return null;
    }
    return new Date(timestamp);
  };
  $asyncSeries = function(series, done) {
    return require("async").series(series, done);
  };
  $asyncEachSeries = function(series, fn, done) {
    return require("async").eachSeries(series, fn, done);
  };
  BocoMigrateError = (function(superClass) {
    extend(BocoMigrateError, superClass);

    function BocoMigrateError(props) {
      $assign(this, props);
      Error.captureStackTrace(this, this.constructor);
      if (this.name == null) {
        this.name = this.constructor.name;
      }
      if (this.message == null) {
        this.message = this.getDefaultMessage();
      }
    }

    return BocoMigrateError;

  })(Error);
  IrreversibleMigration = (function(superClass) {
    extend(IrreversibleMigration, superClass);

    function IrreversibleMigration() {
      return IrreversibleMigration.__super__.constructor.apply(this, arguments);
    }

    IrreversibleMigration.prototype.migration = null;

    IrreversibleMigration.prototype.getDefaultMessage = function() {
      return "Migration '" + this.migration.name + "' is irreversible.";
    };

    return IrreversibleMigration;

  })(BocoMigrateError);
  NotImplemented = (function(superClass) {
    extend(NotImplemented, superClass);

    function NotImplemented() {
      return NotImplemented.__super__.constructor.apply(this, arguments);
    }

    NotImplemented.prototype.getDefaultMessage = function() {
      return "Not implemented";
    };

    return NotImplemented;

  })(BocoMigrateError);
  Migration = (function() {
    Migration.prototype.name = null;

    Migration.prototype.timestamp = null;

    function Migration(props) {
      $assign(this, props);
    }

    Migration.prototype.up = function(done) {
      return done(new NotImplemented());
    };

    Migration.prototype.down = function(done) {
      return done(new IrreversibleMigration({
        migration: this
      }));
    };

    Migration.prototype.getDate = function() {
      return new Date(this.timestamp);
    };

    return Migration;

  })();
  State = (function() {
    State.prototype.lastMigrationName = null;

    State.prototype.lastMigrationTimestamp = null;

    function State(props) {
      $assign(this, props);
    }

    State.prototype.setLastMigration = function(migration) {
      var ref, ref1;
      if (migration == null) {
        migration = {};
      }
      this.lastMigrationTimestamp = (ref = migration.timestamp) != null ? ref : null;
      return this.lastMigrationName = (ref1 = migration.name) != null ? ref1 : null;
    };

    return State;

  })();
  MemoryStateStore = (function() {
    MemoryStateStore.prototype.stateObject = null;

    function MemoryStateStore(props) {
      $assign(this, props);
    }

    MemoryStateStore.prototype.save = function(state, done) {
      this.stateObject.lastMigrationName = state.lastMigrationName;
      this.stateObject.lastMigrationTimestamp = state.lastMigrationTimestamp;
      return done();
    };

    MemoryStateStore.prototype.fetch = function(done) {
      return done(null, new State(this.stateObject));
    };

    return MemoryStateStore;

  })();
  Migrations = (function() {
    Migrations.prototype.collection = null;

    function Migrations(props) {
      $assign(this, props);
      this.collection = this.collection != null ? this.collection.slice() : [];
    }

    Migrations.prototype.add = function(migration) {
      return this.collection.push(migration);
    };

    Migrations.prototype.getMigrationBefore = function(migration) {
      var migrationIndex;
      migrationIndex = this.collection.indexOf(migration);
      return this.collection[migrationIndex - 1];
    };

    Migrations.prototype.sortAscByDate = function() {
      var collection;
      collection = this.collection.sort(function(a, b) {
        return a.getDate() - b.getDate();
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.sortDescByDate = function() {
      var collection;
      collection = this.collection.sort(function(a, b) {
        return b.getDate() - a.getDate();
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.afterTimestamp = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() > date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.beforeIncludingTimestamp = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() <= date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.forMigratingUpTo = function(targetTimestamp, currentTimestamp) {
      return this.afterTimestamp(currentTimestamp).beforeIncludingTimestamp(targetTimestamp).sortAscByDate();
    };

    Migrations.prototype.forMigratingDownTo = function(targetTimestamp, currentTimestamp) {
      return this.afterTimestamp(targetTimestamp).beforeIncludingTimestamp(currentTimestamp).sortDescByDate();
    };

    Migrations.prototype.toArray = function() {
      return this.collection.slice();
    };

    return Migrations;

  })();
  Migrator = (function() {
    Migrator.prototype.migrations = null;

    Migrator.prototype.stateStore = null;

    function Migrator(props) {
      $assign(this, props);
      if (this.migrations == null) {
        this.migrations = new Migrations();
      }
      if (this.stateStore == null) {
        this.stateStore = new MemoryStateStore();
      }
    }

    Migrator.prototype.addMigration = function(migration) {
      return this.migrations.add(migration);
    };

    Migrator.prototype.down = function() {
      var args, done, i, ref, targetTimestamp;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), done = arguments[i++];
      targetTimestamp = (ref = args[0]) != null ? ref : null;
      return this.stateStore.fetch((function(_this) {
        return function(error, state) {
          var currentTimestamp, migrations, runMigration;
          if (error != null) {
            return done(error);
          }
          currentTimestamp = state.lastMigrationTimestamp;
          migrations = _this.migrations.forMigratingDownTo(targetTimestamp, currentTimestamp);
          runMigration = function(migration, done) {
            return migration.down(function(error) {
              var previousMigration;
              if (error != null) {
                return done(error);
              }
              state = new State();
              previousMigration = _this.migrations.sortAscByDate().getMigrationBefore(migration);
              state.setLastMigration(previousMigration);
              return _this.stateStore.save(state, done);
            });
          };
          return $asyncEachSeries(migrations.toArray(), runMigration, done);
        };
      })(this));
    };

    Migrator.prototype.up = function() {
      var args, done, i, ref, targetTimestamp;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), done = arguments[i++];
      targetTimestamp = (ref = args[0]) != null ? ref : null;
      return this.stateStore.fetch((function(_this) {
        return function(error, state) {
          var currentTimestamp, migrations, runMigration;
          if (error != null) {
            return done(error);
          }
          currentTimestamp = state.lastMigrationTimestamp;
          migrations = _this.migrations.forMigratingUpTo(targetTimestamp, currentTimestamp);
          runMigration = function(migration, done) {
            return migration.up(function(error) {
              if (error != null) {
                return done(error);
              }
              state = new State();
              state.setLastMigration(migration);
              return _this.stateStore.save(state, done);
            });
          };
          return $asyncEachSeries(migrations.toArray(), runMigration, done);
        };
      })(this));
    };

    return Migrator;

  })();
  return BocoMigrate = {
    IrreversibleMigration: IrreversibleMigration,
    Migration: Migration,
    State: State,
    Migrator: Migrator,
    MemoryStateStore: MemoryStateStore
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
