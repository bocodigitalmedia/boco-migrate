// Generated by CoffeeScript 1.10.0
var configure,
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

configure = function(dependencies) {
  var $assign, $asyncEachSeries, $asyncSeries, $getTimestampDate, BocoMigrate, BocoMigrateError, IrreversibleMigration, MemoryStateStore, Migration, Migrations, Migrator, NotImplemented, State;
  $assign = function(target, source) {
    var key, results, val;
    results = [];
    for (key in source) {
      if (!hasProp.call(source, key)) continue;
      val = source[key];
      results.push(target[key] = val);
    }
    return results;
  };
  $getTimestampDate = function(timestamp) {
    if (timestamp == null) {
      return null;
    }
    return new Date(timestamp);
  };
  $asyncSeries = function(series, done) {
    return require("async").series(series, done);
  };
  $asyncEachSeries = function(series, fn, done) {
    return require("async").eachSeries(series, fn, done);
  };
  BocoMigrateError = (function(superClass) {
    extend(BocoMigrateError, superClass);

    function BocoMigrateError(props) {
      $assign(this, props);
      Error.captureStackTrace(this, this.constructor);
      if (this.name == null) {
        this.name = this.constructor.name;
      }
      if (this.message == null) {
        this.message = this.getDefaultMessage();
      }
    }

    return BocoMigrateError;

  })(Error);
  IrreversibleMigration = (function(superClass) {
    extend(IrreversibleMigration, superClass);

    function IrreversibleMigration() {
      return IrreversibleMigration.__super__.constructor.apply(this, arguments);
    }

    IrreversibleMigration.prototype.migration = null;

    IrreversibleMigration.prototype.getDefaultMessage = function() {
      return "Migration '" + this.migration.name + "' is irreversible.";
    };

    return IrreversibleMigration;

  })(BocoMigrateError);
  NotImplemented = (function(superClass) {
    extend(NotImplemented, superClass);

    function NotImplemented() {
      return NotImplemented.__super__.constructor.apply(this, arguments);
    }

    NotImplemented.prototype.getDefaultMessage = function() {
      return "Not implemented";
    };

    return NotImplemented;

  })(BocoMigrateError);
  Migration = (function() {
    Migration.prototype.name = null;

    Migration.prototype.timestamp = null;

    function Migration(props) {
      $assign(this, props);
    }

    Migration.prototype.up = function(done) {
      return done(new NotImplemented());
    };

    Migration.prototype.down = function(done) {
      return done(new IrreversibleMigration({
        migration: this
      }));
    };

    Migration.prototype.getDate = function() {
      return new Date(this.timestamp);
    };

    return Migration;

  })();
  State = (function() {
    State.prototype.lastMigrationName = null;

    State.prototype.lastMigrationTimestamp = null;

    function State(props) {
      $assign(this, props);
    }

    State.prototype.setMigration = function(migration) {
      this.lastMigrationTimestamp = migration.timestamp;
      return this.lastMigrationName = migration.name;
    };

    return State;

  })();
  MemoryStateStore = (function() {
    MemoryStateStore.prototype.stateObject = null;

    function MemoryStateStore(props) {
      $assign(this, props);
    }

    MemoryStateStore.prototype.save = function(state, done) {
      this.stateObject.lastMigrationName = state.lastMigrationName;
      this.stateObject.lastMigrationTimestamp = state.lastMigrationTimestamp;
      return done();
    };

    MemoryStateStore.prototype.fetch = function(done) {
      return done(null, new State(this.stateObject));
    };

    return MemoryStateStore;

  })();
  Migrations = (function() {
    Migrations.prototype.collection = null;

    function Migrations(props) {
      $assign(this, props);
      this.collection = this.collection != null ? this.collection.slice() : [];
    }

    Migrations.prototype.add = function(migration) {
      return this.collection.push(migration);
    };

    Migrations.prototype.sortByDate = function(ascending) {
      var collection;
      if (ascending == null) {
        ascending = true;
      }
      collection = this.collection.sort(function(a, b) {
        if (ascending) {
          return a.getDate() - b.getDate();
        }
        return b.getDate() - a.getDate();
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.after = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() > date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.beforeIncluding = function(timestamp) {
      var collection, date;
      date = $getTimestampDate(timestamp);
      if (date == null) {
        return this;
      }
      collection = this.collection.filter(function(migration) {
        return migration.getDate() <= date;
      });
      return new Migrations({
        collection: collection
      });
    };

    Migrations.prototype.toArray = function() {
      return this.collection.slice();
    };

    return Migrations;

  })();
  Migrator = (function() {
    Migrator.prototype.migrations = null;

    Migrator.prototype.state = null;

    function Migrator(props) {
      $assign(this, props);
      if (this.migrations == null) {
        this.migrations = new Migrations();
      }
      if (this.state == null) {
        this.state = new State();
      }
    }

    Migrator.prototype.addMigration = function(migration) {
      return this.migrations.add(migration);
    };

    Migrator.prototype.up = function(done) {
      var migrations, runMigration;
      migrations = this.migrations.after(this.state.lastMigrationTimestamp).sortByDate().toArray();
      runMigration = (function(_this) {
        return function(migration, done) {
          var migrateUp, saveState;
          console.log("-> " + migration.name);
          migrateUp = function(done) {
            return migration.up(done);
          };
          saveState = function(done) {
            _this.state.setMigration(migration);
            return _this.stateStore.save(_this.state, done);
          };
          return $asyncSeries([migrateUp, saveState], done);
        };
      })(this);
      return $asyncEachSeries(migrations, runMigration, done);
    };

    return Migrator;

  })();
  return BocoMigrate = {
    IrreversibleMigration: IrreversibleMigration,
    Migration: Migration,
    State: State,
    Migrator: Migrator,
    MemoryStateStore: MemoryStateStore
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
